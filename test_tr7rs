; Tests for tr7rs
(+ 1 1)
(* 2 3)
(* (+ 1 1) 3)
(= 1 2)
(if (= 1 1) 1 2)
(list 1 2 3)
(car (list 1 2 3))
(cdr (list 1 2 3))
(cons 1 (list 2 3))
(cons (list 1 2) (list 3 4))
(define a (list 1 2))
(car a)
(cdr a)
(null? (list))
(null? (list 1))
(null? 3)
(define plus1 (lambda (x) (+ x 1)))
(define add (lambda (x y) (+ x y)))
(plus1 1)
(add 2 3)
(define fact (lambda (n) (if (< n 2) 1 (* n (fact (- n 1))))))
(define S 5)
(foo)
(fact 10)
(((lambda (mk-length) (mk-length mk-length)) (lambda (mk-length) (lambda (l) (if (null? l) 0 (+ 1 ((mk-length mk-length) (cdr l))))))) (list 1 2 3))
(define Y (lambda (le) ((lambda (f) (f f)) (lambda (f) (le (lambda (x) ((f f) x)))))))
(define Y2 (lambda (le) ((lambda (f) (f f)) (lambda (f) (le (lambda (x1 x2) ((f f) x1 x2)))))))
(define YS (lambda (le) ((lambda (f) (f f)) (lambda (f) (le (lambda x (apply (f f) x)))))))
(define facty (Y (lambda (facty) (lambda (n) (if (< n 2) 1 (* n (facty (- n 1))))))))
(facty 10)
(define fooy2 (Y2 (lambda (fooy2) (lambda (l a) (cond ((null? l) a) (else (+ 1 (fooy2 (cdr l) a))))))))
(fooy2 '(a b) 5)
(define fooys (YS (lambda (fooys) (lambda k (cond ((null? (car k)) (car (cdr k))) (else (+ 1 (fooys (cdr (car k)) (car (cdr k))))))))))
(define foos                      (lambda k (cond ((null? (car k)) (car (cdr k))) (else (+ 1 (foos  (cdr (car k)) (car (cdr k))))))))
(fooys '(a b c) 9)
(foos '(a b c) 9)
(quote a)
(quote (1 a))
'a
(list 'a 'b)
'(a b c)
(zero? 0)
(zero? 4)
(not #f)
(not #t)
(eq? #f #f)
(eq? 'a 'b)
(eq? 'a 'a)
(eq? '() '())
(number? 1)
(number? 'a)
(pair? '(a))
(pair? 3)
(cond ((> 3 2) 'greater)  ((< 3 2) 'less))
(cond ((> 3 4) 'greater)  ((< 3 4) 'less))
(cond ((> 3 3) 'greater)  ((< 3 3) 'less))
(cond ((> 3 3) 'greater) ((< 3 3) 'less) (else 'equal))
(and (= 1 1) (= 2 2))
(and (= 1 1))
(and)
(or (= 1 1) (= 1 2))
(or #f #f)
(or #t)
(or)
(define m 3)
(define fact_part (lambda (factya) (lambda (n) (if (< n 2) 1 (* n (factya (- n 1)))))))
(define factya (Y fact_part))
(factya 10)
(boolean? #f)
(boolean? 'a)
(symbol? 'a)
(symbol? #t)
(procedure? factya)
(procedure? 1)
(apply + '(3 4))
(define compose (lambda (f g) (lambda args (f (apply g args)))))
((compose - *) 3 4)
(define add1 (lambda (x) (+ 1 x)))
(apply add1 '(3))
((lambda x (define a (+ (car x) 2)) a) 3)
((lambda (x) (define a (+ x 3)) a) 6)
(let ((a 2) (b 3)) (+ a b))
(+ 41
1)
